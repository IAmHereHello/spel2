<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The 180 Degree Shooter - Ultimate Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #2a2a4e 0%, #1a1a2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: flex;
            gap: 20px;
        }

        .ui-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        #score-display {
            font-size: 24px;
            font-weight: bold;
            color: #4cc9f0;
            text-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
        }

        #level-display {
            font-size: 14px;
            color: #ccc;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #powerup-display {
            font-size: 20px;
            color: #ffbe0b;
            font-weight: bold;
            display: none;
        }

        /* ITEMS BAR */
        #item-bar {
            position: absolute;
            bottom: 30px;
            right: 30px;
            pointer-events: auto;
            display: flex;
            gap: 20px;
        }

        .item-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .item-slot.locked {
            opacity: 0.5;
            filter: grayscale(1);
            pointer-events: none;
        }

        .item-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #444;
            border: 4px solid #666;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            cursor: not-allowed;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
            overflow: hidden;
        }

        /* Ready States */
        .item-btn.ready-fire {
            background: radial-gradient(circle, #ff9f1c, #d00000);
            border-color: #ffba08;
            cursor: pointer;
            box-shadow: 0 0 30px #d00000;
            animation: pulse 2s infinite;
        }

        .item-btn.ready-laser {
            background: radial-gradient(circle, #4cc9f0, #4361ee);
            border-color: #4cc9f0;
            cursor: pointer;
            box-shadow: 0 0 30px #4361ee;
            animation: pulse 2s infinite;
        }

        .item-btn.active-laser {
            background: white;
            box-shadow: 0 0 50px white;
            border-color: white;
            transform: scale(1.1);
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Height animates */
            background: rgba(0, 0, 0, 0.6);
            transition: height 0.1s linear;
        }

        .item-label {
            margin-top: 10px;
            font-weight: bold;
            text-shadow: 0 0 5px black;
            color: #aaa;
            font-size: 12px;
            text-transform: uppercase;
        }

        .item-slot.locked .item-label {
            content: "LOCKED";
        }

        .lock-icon {
            display: none;
            position: absolute;
            font-size: 24px;
        }

        .item-slot.locked .lock-icon {
            display: block;
        }

        /* Floating Text (Rage Feedback) */
        .float-text {
            position: absolute;
            color: #ff0000;
            font-weight: bold;
            font-size: 24px;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 0 0 10px black;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.5);
            }
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 10;
        }

        h1 {
            font-size: 64px;
            margin-bottom: 10px;
            background: linear-gradient(to right, #f72585, #7209b7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 30px rgba(247, 37, 133, 0.5);
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(135deg, #4cc9f0, #4361ee);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.4);
        }

        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(76, 201, 240, 0.8);
        }

        .level-up-notif {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #ffbe0b;
            text-shadow: 0 0 20px rgba(255, 190, 11, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s, transform 0.5s;
        }

        .level-up-notif.active {
            opacity: 1;
            transform: translate(-50%, -80%);
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 20;
            color: white;
            font-size: 24px;
            cursor: default;
        }

        .start-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(135deg, #4cc9f0, #4361ee);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.4);
            text-decoration: none;
        }

        .start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(76, 201, 240, 0.8);
        }

        .tutorial-btn {
            padding: 10px 30px;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tutorial-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
        }

        #tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 30;
        }

        .tutorial-box {
            background: #1a1a2e;
            border: 1px solid #4361ee;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 50px rgba(67, 97, 238, 0.3);
            position: relative;
        }

        .tutorial-step {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .tutorial-step.active {
            display: flex;
        }

        .tutorial-title {
            font-size: 32px;
            color: #4cc9f0;
            margin-bottom: 10px;
        }

        .tutorial-text {
            font-size: 20px;
            line-height: 1.6;
            color: #ccc;
        }

        .tutorial-controls {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            justify-content: center;
        }

        .tut-nav-btn {
            padding: 10px 24px;
            border-radius: 8px;
            border: none;
            background: #333;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .tut-nav-btn:hover {
            background: #555;
        }

        .tut-nav-btn.primary {
            background: #4361ee;
        }

        .tut-nav-btn.primary:hover {
            background: #3a0ca3;
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div class="ui-box">
            <div id="score-display">Score: 0</div>
            <div id="level-display">Level 1</div>
        </div>
        <div class="ui-box" id="powerup-box" style="display:none;">
            <div id="powerup-display"></div>
        </div>
    </div>

    <div id="item-bar">
        <!-- Fire Amulet (Lvl 4) -->
        <div id="slot-fire" class="item-slot locked">
            <div id="btn-fire" class="item-btn" onclick="activateFire()">
                <span class="icon">üî•</span>
                <span class="lock-icon">üîí</span>
                <div id="overlay-fire" class="cooldown-overlay"></div>
            </div>
            <div id="label-fire" class="item-label">Lvl 4</div>
        </div>

        <!-- Laser Amulet (Lvl 6) -->
        <div id="slot-laser" class="item-slot locked">
            <div id="btn-laser" class="item-btn" onclick="activateLaser()">
                <span class="icon">‚ö°</span>
                <span class="lock-icon">üîí</span>
                <div id="overlay-laser" class="cooldown-overlay"></div>
            </div>
            <div id="label-laser" class="item-label">Lvl 6</div>
        </div>
    </div>

    <div id="level-up-msg" class="level-up-notif">LEVEL UP!</div>

    <div id="game-over-screen">
        <h1 id="game-over-title">GAME OVER</h1>
        <div style="font-size: 28px; margin-bottom: 40px; color: #ccc;" id="final-score">Score: 0</div>
        <button onclick="resetGame()">Play Again</button>
    </div>

    <div id="start-overlay">
        <h1>180¬∞ SHOOTER</h1>
        <button class="start-btn" onclick="startGame()">START SPEL</button>
        <button class="tutorial-btn" onclick="showTutorial()">HOE TE SPELEN</button>
    </div>

    <div id="tutorial-overlay">
        <div class="tutorial-box">
            <!-- Step 1 -->
            <div class="tutorial-step active" id="tut-step-1">
                <div class="tutorial-title">Welkom!</div>
                <div class="tutorial-text">
                    Welkom bij de <b>180 Graden Shooter</b>!<br><br>
                    De ballen rollen over het pad naar het eindpunt.<br>
                    Jij moet voorkomen dat ze daar komen!
                </div>
            </div>

            <!-- Step 2 -->
            <div class="tutorial-step" id="tut-step-2">
                <div class="tutorial-title">De Regel</div>
                <div class="tutorial-text">
                    Elke bal die je schiet moet samen met de bal die je raakt<br>
                    <b>precies 180 graden</b> vormen.<br><br>
                    Op de ballen staan twee hoeken (bijv. 60¬∞, 60¬∞).<br>
                    Jij moet de ontbrekende hoek schieten!
                </div>
            </div>

            <!-- Step 3 -->
            <div class="tutorial-step" id="tut-step-3">
                <div class="tutorial-title">Rekenvoorbeeld</div>
                <div class="tutorial-text">
                    Stel een bal heeft de hoeken <b>60¬∞</b> en <b>60¬∞</b>.<br>
                    Samen is dat 120¬∞.<br><br>
                    Om 180¬∞ te maken, heb je nog <b>60¬∞</b> nodig.<br>
                    Schiet dus een 60¬∞ bal om hem weg te spelen!
                </div>
            </div>

            <!-- Step 4 -->
            <div class="tutorial-step" id="tut-step-4">
                <div class="tutorial-title">Besturing & Pas op!</div>
                <div class="tutorial-text">
                    Richt met je muis en klik om te schieten.<br><br>
                    ‚ö†Ô∏è <b>NIET SPAMMEN!</b> ‚ö†Ô∏è<br>
                    Als je te snel achter elkaar klikt, wordt het spel sneller en moeilijker.
                    Mik goed en schiet rustig.
                </div>
            </div>

            <!-- Step 5 -->
            <div class="tutorial-step" id="tut-step-5">
                <div class="tutorial-title">Powerups</div>
                <div class="tutorial-text">
                    In hogere levels speel je speciale krachten vrij:<br>
                    üî• <b>Vuur (Lvl 4)</b>: Blaas een groep ballen op.<br>
                    ‚ö° <b>Laser (Lvl 6)</b>: Vernietig ballen met je muis.<br><br>
                    Veel succes!
                </div>
            </div>

            <div class="tutorial-controls">
                <button class="tut-nav-btn" id="tut-prev" onclick="prevStep()">Vorige</button>
                <button class="tut-nav-btn primary" id="tut-next" onclick="nextStep()">Volgende</button>
                <button class="tut-nav-btn primary" id="tut-close" onclick="closeTutorial()"
                    style="display:none;">Sluiten</button>
            </div>
        </div>
    </div>

    <div id="start-overlay-click-handler" style="display:none;" onclick="startGame()"></div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- AUDIO MANAGER ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        const SoundManager = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playShoot: () => {
                SoundManager.playTone(600, 'sine', 0.1, 0.1);
                // Pitch drop
                if (audioCtx.state === 'suspended') return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            },
            playHit: () => {
                // Thud
                SoundManager.playTone(100, 'square', 0.1, 0.05);
            },
            playMatch: () => {
                // Ding
                SoundManager.playTone(880, 'sine', 0.3, 0.1);
                setTimeout(() => SoundManager.playTone(1100, 'sine', 0.3, 0.1), 50);
            },
            playExplosion: () => {
                if (audioCtx.state === 'suspended') return;
                const bufferSize = audioCtx.sampleRate * 0.5; // 0.5 sec
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                noise.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
            },
            playLaser: () => {
                // Buzz
                if (audioCtx.state === 'suspended') return;
                const osc = audioCtx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            },
            playError: () => {
                // Error / Rage Sound (Low Sawtooth Drop)
                if (audioCtx.state === 'suspended') return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            }
        };

        // --- TUTORIAL SYSTEM ---
        let currentStep = 1;
        const totalSteps = 5;

        function showTutorial() {
            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('tutorial-overlay').style.display = 'flex';
            currentStep = 1;
            updateTutorialUI();
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            document.getElementById('start-overlay').style.display = 'flex';
        }

        function nextStep() {
            if (currentStep < totalSteps) {
                currentStep++;
                updateTutorialUI();
            } else {
                closeTutorial();
            }
        }

        function prevStep() {
            if (currentStep > 1) {
                currentStep--;
                updateTutorialUI();
            }
        }

        function updateTutorialUI() {
            // Hide all steps
            for (let i = 1; i <= totalSteps; i++) {
                document.getElementById(`tut-step-${i}`).classList.remove('active');
            }
            // Show current
            document.getElementById(`tut-step-${currentStep}`).classList.add('active');

            // Buttons
            const btnPrev = document.getElementById('tut-prev');
            const btnNext = document.getElementById('tut-next');
            const btnClose = document.getElementById('tut-close');

            if (currentStep === 1) {
                btnPrev.style.display = 'none';
            } else {
                btnPrev.style.display = 'block';
            }

            if (currentStep === totalSteps) {
                btnNext.style.display = 'none';
                btnClose.style.display = 'block';
            } else {
                btnNext.style.display = 'block';
                btnClose.style.display = 'none';
                btnNext.innerText = "Volgende";
            }
        }

        function startGame() {
            document.getElementById('start-overlay').style.display = 'none';
            if (audioCtx.state === 'suspended') audioCtx.resume();
            init();
        }

        // --- Game Config ---
        const config = {
            ballRadius: 32,
            ballSpeed: 0.5,
            backSpeed: 3.0,
            ballSpacing: 58,
            shotSpeed: 20,
            spawnInterval: 48,
            shootDelay: 15,
            powerupChance: 0.08,

            // Fire Amulet
            fireCooldownMax: 1200,
            fireChargeReq: 10,

            // Laser Amulet
            laserCooldownMax: 2400, // 40s
            laserDuration: 600,     // 10s

            // Rage (Anti-Spam)
            rageDuration: 150,  // 2.5s
            spamThreshold: 800, // ms between shots to count as 'fast'
        };

        // --- MATH DEFINITIONS ---
        const ANGLE_DEFS = [
            { a: 50, b: 60, c: 70 },
            { a: 90, b: 40, c: 50 },
            { a: 30, b: 30, c: 120 },
            { a: 45, b: 45, c: 90 },
            { a: 60, b: 60, c: 60 },
            { a: 20, b: 80, c: 80 },
            { a: 100, b: 40, c: 40 }
        ];

        let COLOR_POOL = [
            '#FF595E', '#FFCA3A', '#8AC926', '#1982C4', '#6A4C93', '#FB5607', '#FF006E'
        ];

        let typeColorMap = [];

        const POWERUPS = [
            { type: 'flame', icon: 'üî•', duration: 0 },
            { type: 'freeze', icon: '‚ùÑÔ∏è', duration: 300 },
            { type: 'reverse', icon: '‚è™', duration: 180 }
        ];

        // --- State ---
        let balls = [];
        let projectiles = [];
        let particles = [];
        let pathPoints = [];
        let shooter = {
            x: 0, y: 0, angle: 0,
            nextBall: null,
            queue: [],
            cooldown: 0
        };
        let score = 0;
        let gameState = 'waiting';
        let mouseX = 0;
        let mouseY = 0;
        let spawnTimer = 0;

        let activeTypeCount = 3;
        let currentLevel = 1;

        // Effect State
        let freezeTimer = 0;
        let reverseTimer = 0;
        let rageTimer = 0;
        let currentRageMultiplier = 1.0;

        // Spam Detection
        let lastShotTime = 0;
        let spamStreak = 0;

        // Items State
        let fireState = { unlocked: false, cooldown: 0, charge: 0 };
        let laserState = { unlocked: false, cooldown: 0, active: false, timer: 0, tick: 0 };

        function rnd(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function shuffleColors() {
            for (let i = COLOR_POOL.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [COLOR_POOL[i], COLOR_POOL[j]] = [COLOR_POOL[j], COLOR_POOL[i]];
            }
            typeColorMap = [];
            for (let i = 0; i < ANGLE_DEFS.length; i++) {
                typeColorMap.push(COLOR_POOL[i]);
            }
            projectiles.forEach(p => {
                p.color = typeColorMap[p.typeIndex];
            });
        }

        function generatePath() {
            pathPoints = [];
            const w = canvas.width;
            const h = canvas.height;
            const steps = 3000;

            for (let i = 0; i <= steps; i++) {
                let t = i / steps;
                let x, y;
                const cx = w / 2;
                const cy = h / 2;
                const maxR = Math.min(w, h) * 0.45;
                const loops = 2.5;
                const angleOffset = Math.PI;
                const r = maxR * (1 - t);
                const theta = angleOffset + t * loops * Math.PI * 2;

                x = cx + r * Math.cos(theta);
                y = cy + r * Math.sin(theta);
                pathPoints.push({ x, y });
            }
        }

        class Ball {
            constructor(distance, typeIndex = -1) {
                this.distance = distance;
                this.active = true;

                if (typeIndex === -1) {
                    typeIndex = rnd(0, activeTypeCount - 1);
                }
                this.typeIndex = typeIndex;
                const type = ANGLE_DEFS[typeIndex];

                this.angles = [type.a, type.b];
                this.requiredAngle = type.c;

                this.powerup = null;
                if (Math.random() < config.powerupChance) {
                    this.powerup = POWERUPS[rnd(0, POWERUPS.length - 1)];
                }
            }

            draw() {
                if (!this.active) return;
                const pos = getPositionAtDistance(this.distance);
                if (!pos) return;

                const currentColor = typeColorMap[this.typeIndex];

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, config.ballRadius, 0, Math.PI * 2);
                ctx.fillStyle = currentColor;
                ctx.fill();

                let grad = ctx.createRadialGradient(
                    pos.x - config.ballRadius * 0.3,
                    pos.y - config.ballRadius * 0.3,
                    config.ballRadius * 0.1,
                    pos.x,
                    pos.y,
                    config.ballRadius
                );
                grad.addColorStop(0, 'rgba(255,255,255,0.4)');
                grad.addColorStop(1, 'rgba(0,0,0,0.2)');
                ctx.fillStyle = grad;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(pos.x - config.ballRadius * 0.4, pos.y - config.ballRadius * 0.4, config.ballRadius * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();

                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (this.powerup) {
                    ctx.font = '24px Arial';
                    ctx.fillText(this.powerup.icon, pos.x, pos.y - 12);

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px "Segoe UI", Arial';
                    ctx.fillText(`${this.angles[0]},${this.angles[1]}`, pos.x, pos.y + 14);
                } else {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 20px "Segoe UI", Arial';
                    ctx.fillText(`${this.angles[0]},${this.angles[1]}`, pos.x, pos.y);
                }
            }
        }

        class Projectile {
            constructor(x, y, angle, typeIndex) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * config.shotSpeed;
                this.vy = Math.sin(angle) * config.shotSpeed;

                this.typeIndex = typeIndex;
                const type = ANGLE_DEFS[typeIndex];
                this.value = type.c;
                this.color = typeColorMap[typeIndex];

                this.radius = config.ballRadius;
                this.active = true;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.active = false;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                let grad = ctx.createRadialGradient(
                    this.x - this.radius * 0.3,
                    this.y - this.radius * 0.3,
                    this.radius * 0.1,
                    this.x,
                    this.y,
                    this.radius
                );
                grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                grad.addColorStop(0.5, 'rgba(200,200,255,0.3)');
                grad.addColorStop(1, 'rgba(255,255,255,0.1)');

                ctx.fillStyle = grad;
                ctx.fill();

                ctx.strokeStyle = 'rgba(200, 200, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 22px "Segoe UI", Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(this.value + '¬∞', this.x, this.y);
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                // Faster explosion speed (Splatter)
                const speed = Math.random() * 8 + 4;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 6 + 3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.03;
                this.size *= 0.92;
                this.vx *= 0.95;
                this.vy *= 0.95;
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function getPositionAtDistance(dist) {
            if (pathPoints.length === 0) return { x: 0, y: 0 };
            if (dist < 0) return pathPoints[0];

            const totalLen = _totalPathLength;
            let percent = dist / totalLen;
            if (percent >= 1) return null;

            let idx = Math.floor(percent * pathPoints.length);
            return pathPoints[idx];
        }

        let _totalPathLength = 0;
        function calculatePathLength() {
            let d = 0;
            for (let i = 1; i < pathPoints.length; i++) {
                const dx = pathPoints[i].x - pathPoints[i - 1].x;
                const dy = pathPoints[i].y - pathPoints[i - 1].y;
                d += Math.sqrt(dx * dx + dy * dy);
            }
            _totalPathLength = d;
        }

        function init() {
            resize();
            resetGame();
            window.addEventListener('resize', resize);
            window.addEventListener('mousemove', e => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            window.addEventListener('mousedown', shoot);
            requestAnimationFrame(loop);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            shooter.x = canvas.width / 2;
            shooter.y = canvas.height / 2;
            generatePath();
            calculatePathLength();
        }

        function resetGame() {
            balls = [];
            projectiles = [];
            particles = [];
            score = 0;
            activeTypeCount = 3;
            currentLevel = 1;
            freezeTimer = 0;
            reverseTimer = 0;
            rageTimer = 0;
            currentRageMultiplier = 1.0;
            lastShotTime = 0;
            spamStreak = 0;

            fireState = { unlocked: false, cooldown: 0, charge: 0 };
            laserState = { unlocked: false, cooldown: 0, active: false, timer: 0, tick: 0 };

            document.getElementById('slot-fire').className = "item-slot locked";
            document.getElementById('slot-laser').className = "item-slot locked";
            document.getElementById('label-fire').innerText = "LOCKED (Lvl 4)";
            document.getElementById('label-laser').innerText = "LOCKED (Lvl 6)";

            shooter.queue = [];
            shuffleColors();
            for (let i = 0; i < 3; i++) {
                shooter.queue.push(rnd(0, activeTypeCount - 1));
            }

            document.getElementById('score-display').innerText = `Score: 0`;
            document.getElementById('level-display').innerText = `Level 1`;
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('powerup-box').style.display = 'none';

            // Clear floating text
            const floats = document.querySelectorAll('.float-text');
            floats.forEach(el => el.remove());

            gameState = 'playing';
            spawnTimer = 0;
            reloadShooter();
        }

        function reloadShooter() {
            let typeIdx = shooter.queue.shift();

            let newType = rnd(0, activeTypeCount - 1);
            if (balls.length > 0 && Math.random() > 0.4) {
                const existing = balls[rnd(0, balls.length - 1)];
                newType = existing.typeIndex;
            }
            shooter.queue.push(newType);

            shooter.nextBall = {
                typeIndex: typeIdx,
                angle: ANGLE_DEFS[typeIdx].c,
                color: typeColorMap[typeIdx]
            };
        }

        function shoot() {
            if (gameState !== 'playing') return;
            if (laserState.active) return;

            if (mouseX > window.innerWidth - 250 && mouseY > window.innerHeight - 150) {
                return;
            }

            if (shooter.cooldown > 0) return;
            if (!shooter.nextBall) return;

            // SPAM CHECK (Progressive)
            const now = Date.now();
            if (now - lastShotTime < config.spamThreshold) {
                spamStreak++;

                if (spamStreak === 5) {
                    createFloatText(shooter.x, shooter.y - 100, "NIET SPAMMEN (1/3)");
                } else if (spamStreak === 6) {
                    createFloatText(shooter.x, shooter.y - 100, "NIET SPAMMEN (2/3)");
                } else if (spamStreak === 7) {
                    createFloatText(shooter.x, shooter.y - 100, "STOP NU!");
                } else if (spamStreak >= 8) {
                    rageTimer = config.rageDuration;

                    // Progressive Speed: Base 6.0 + 2.0 for every extra click
                    let extra = spamStreak - 8;
                    currentRageMultiplier = 6.0 + (extra * 2.0);

                    SoundManager.playError();
                    createFloatText(shooter.x, shooter.y - 150, "SUCCES");
                    // We do NOT reset spamStreak here, so it climbs to 9, 10, etc.
                }
            } else {
                spamStreak = 0;
                currentRageMultiplier = 1.0;
            }
            lastShotTime = now;

            SoundManager.playShoot(); // SFX

            projectiles.push(new Projectile(
                shooter.x,
                shooter.y,
                shooter.angle,
                shooter.nextBall.typeIndex
            ));

            shooter.cooldown = config.shootDelay;
            reloadShooter();
        }

        function checkLevelUp() {
            let nextLevel = 1;
            if (score >= 500) nextLevel = 2;
            if (score >= 1500) nextLevel = 3;
            if (score >= 3000) nextLevel = 4;
            if (score >= 5000) nextLevel = 5;
            if (score >= 7500) nextLevel = 6;
            if (score >= 10000) nextLevel = 7;

            if (nextLevel > currentLevel) {
                currentLevel = nextLevel;
                shuffleColors();
                activeTypeCount++;
                if (activeTypeCount > ANGLE_DEFS.length) activeTypeCount = ANGLE_DEFS.length;

                const msg = document.getElementById('level-up-msg');
                msg.classList.add('active');
                setTimeout(() => msg.classList.remove('active'), 2000);

                document.getElementById('level-display').innerText = `Level ${currentLevel}`;

                if (currentLevel >= 4 && !fireState.unlocked) {
                    fireState.unlocked = true;
                    document.getElementById('slot-fire').classList.remove('locked');
                    document.getElementById('label-fire').innerText = "Charging 0/10";
                }
                if (currentLevel >= 6 && !laserState.unlocked) {
                    laserState.unlocked = true;
                    document.getElementById('slot-laser').classList.remove('locked');
                    document.getElementById('label-laser').innerText = "Reference";
                }
            }
        }

        function updateItems() {
            if (fireState.unlocked) {
                if (fireState.cooldown > 0) fireState.cooldown--;

                const btn = document.getElementById('btn-fire');
                const label = document.getElementById('label-fire');
                const overlay = document.getElementById('overlay-fire');

                if (fireState.cooldown > 0) {
                    let pct = fireState.cooldown / config.fireCooldownMax;
                    overlay.style.height = (pct * 100) + '%';
                    label.innerText = `${Math.ceil(fireState.cooldown / 60)}s`;
                    btn.classList.remove('ready-fire');
                } else if (fireState.charge < config.fireChargeReq) {
                    overlay.style.height = '0%';
                    label.innerText = `${fireState.charge}/${config.fireChargeReq}`;
                    btn.classList.remove('ready-fire');
                } else {
                    overlay.style.height = '0%';
                    label.innerText = `READY!`;
                    btn.classList.add('ready-fire');
                }
            }

            if (laserState.unlocked) {
                if (laserState.cooldown > 0 && !laserState.active) {
                    laserState.cooldown--;
                }

                const btn = document.getElementById('btn-laser');
                const label = document.getElementById('label-laser');
                const overlay = document.getElementById('overlay-laser');

                if (laserState.active) {
                    btn.classList.add('active-laser');
                    label.innerText = "ACTIVE!";
                    overlay.style.height = '0%';

                    laserState.timer--;
                    if (laserState.timer <= 0) {
                        laserState.active = false;
                        laserState.cooldown = config.laserCooldownMax;
                        btn.classList.remove('active-laser');
                    } else {
                        laserLogic();
                    }
                } else {
                    if (laserState.cooldown > 0) {
                        let pct = laserState.cooldown / config.laserCooldownMax;
                        overlay.style.height = (pct * 100) + '%';
                        label.innerText = `${Math.ceil(laserState.cooldown / 60)}s`;
                        btn.classList.remove('ready-laser');
                    } else {
                        overlay.style.height = '0%';
                        label.innerText = `READY!`;
                        btn.classList.add('ready-laser');
                    }
                }
            }
        }

        function activateFire() {
            if (!fireState.unlocked) return;
            if (fireState.cooldown > 0) return;
            if (fireState.charge < config.fireChargeReq) return;
            if (balls.length === 0) return;

            let count = Math.min(balls.length, 10);
            for (let i = 0; i < count; i++) {
                SoundManager.playExplosion();
                createExplosion(getPositionAtDistance(balls[i].distance), '#FF0000');
            }

            balls.splice(0, count);
            fireState.cooldown = config.fireCooldownMax;
            fireState.charge = 0;
            score += 500;
        }

        function activateLaser() {
            if (!laserState.unlocked) return;
            if (laserState.cooldown > 0) return;
            if (laserState.active) return;

            laserState.active = true;
            laserState.timer = config.laserDuration;
        }

        function laserLogic() {
            SoundManager.playLaser(); // SFX loop

            const dx = mouseX - shooter.x;
            const dy = mouseY - shooter.y;
            const angle = Math.atan2(dy, dx);

            let maxDist = Math.max(canvas.width, canvas.height);
            let closestDist = maxDist;
            let hitIndex = -1;

            const sx = shooter.x; const sy = shooter.y;
            const dirX = Math.cos(angle); const dirY = Math.sin(angle);

            for (let i = 0; i < balls.length; i++) {
                const b = balls[i];
                const p = getPositionAtDistance(b.distance);
                if (!p) continue;

                const px = p.x - sx; const py = p.y - sy;
                const t = px * dirX + py * dirY;

                if (t > 0) {
                    const cx = sx + t * dirX;
                    const cy = sy + t * dirY;

                    const distSq = (p.x - cx) ** 2 + (p.y - cy) ** 2;
                    if (distSq < config.ballRadius * config.ballRadius) {
                        if (t < closestDist) {
                            closestDist = t;
                            hitIndex = i;
                        }
                    }
                }
            }

            const endX = sx + closestDist * dirX;
            const endY = sy + closestDist * dirY;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#4361ee';
            ctx.lineWidth = 10 + Math.random() * 5;
            ctx.lineCap = 'round';
            ctx.shadowColor = '#4cc9f0';
            ctx.shadowBlur = 20;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.stroke();

            if (hitIndex !== -1) {
                ctx.beginPath();
                ctx.arc(endX, endY, 20 + Math.random() * 10, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();

                laserState.tick++;
                // FASTER DESTROY (poppen sneller)
                if (laserState.tick > 4) {
                    const b = balls[hitIndex];
                    SoundManager.playExplosion();
                    createExplosion(getPositionAtDistance(b.distance), typeColorMap[b.typeIndex]);
                    balls.splice(hitIndex, 1);
                    laserState.tick = 0;
                    score += 50;
                }
            }
            ctx.restore();
        }

        function createFloatText(x, y, text) {
            const div = document.createElement('div');
            div.className = 'float-text';
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.innerText = text;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        function updateUI() {
            document.getElementById('score-display').innerText = `Score: ${score}`;
        }

        function update() {
            if (gameState !== 'playing') return;

            updateUI();
            checkLevelUp();
            updateItems();

            let globalVelocity = config.ballSpeed;
            let statusText = "";
            let rageActive = (rageTimer > 0);

            if (rageTimer > 0) {
                rageTimer--;
                globalVelocity *= currentRageMultiplier; // RAGE ACCELERATION
                statusText = "üò° RAGE!!!";
            } else if (freezeTimer > 0) {
                freezeTimer--;
                globalVelocity = 0;
                statusText = "‚ùÑÔ∏è FROZEN";
            } else if (reverseTimer > 0) {
                reverseTimer--;
                globalVelocity = -config.ballSpeed * 2;
                statusText = "‚è™ REWIND";
            }

            const pbox = document.getElementById('powerup-box');
            const ptext = document.getElementById('powerup-display');
            if (statusText) {
                pbox.style.display = 'flex';
                ptext.innerText = statusText;
            } else {
                pbox.style.display = 'none';
            }

            let spawningPaused = (freezeTimer > 0 && !rageActive) || reverseTimer > 0 || laserState.active;

            if (!spawningPaused) {
                spawnTimer++;
                if (spawnTimer > config.spawnInterval) {
                    let canSpawn = true;
                    if (balls.length > 0) {
                        let lastBall = balls[balls.length - 1];
                        if (lastBall.distance < config.ballSpacing) {
                            canSpawn = false;
                        }
                    }

                    if (canSpawn) {
                        balls.push(new Ball(0));
                        spawnTimer = 0;
                    }
                }
            }

            if (balls.length > 0) {
                let i = 0;
                while (i < balls.length) {
                    let segmentStart = i;
                    let segmentEnd = i;

                    while (segmentEnd < balls.length - 1) {
                        let lead = balls[segmentEnd];
                        let trail = balls[segmentEnd + 1];
                        if (lead.distance - trail.distance <= config.ballSpacing + 5) {
                            segmentEnd++;
                        } else {
                            break;
                        }
                    }

                    let velocity = globalVelocity;

                    if (!spawningPaused) {
                        if (segmentEnd < balls.length - 1) {
                            let myTail = balls[segmentEnd];
                            let nextHead = balls[segmentEnd + 1];
                            let gap = myTail.distance - nextHead.distance;
                            if (gap > config.ballSpacing + 4) {
                                velocity = -config.backSpeed;
                            }
                        }
                    }

                    for (let k = segmentStart; k <= segmentEnd; k++) {
                        balls[k].distance += velocity;
                    }

                    i = segmentEnd + 1;
                }

                for (let k = 0; k < balls.length - 1; k++) {
                    let lead = balls[k];
                    let trail = balls[k + 1];
                    if (lead.distance - trail.distance < config.ballSpacing) {
                        trail.distance = lead.distance - config.ballSpacing;
                    }
                }
            }

            for (let b of balls) {
                if (b.distance >= _totalPathLength) {
                    gameOver();
                }
            }

            const dx = mouseX - shooter.x;
            const dy = mouseY - shooter.y;
            shooter.angle = Math.atan2(dy, dx);
            if (shooter.cooldown > 0) shooter.cooldown--;

            updateProjectiles();

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
        }

        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                p.update();

                if (!p.active) {
                    projectiles.splice(i, 1);
                    continue;
                }

                let hit = false;
                for (let j = 0; j < balls.length; j++) {
                    let b = balls[j];
                    let bPos = getPositionAtDistance(b.distance);
                    if (!bPos) continue;

                    let dx = bPos.x - p.x;
                    let dy = bPos.y - p.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < config.ballRadius * 2) {
                        hit = true;
                        handleCollision(p, j);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }

        function handleCollision(projectile, ballIndex) {
            let target = balls[ballIndex];
            let sum = target.angles[0] + target.angles[1] + projectile.value;

            if (sum === 180) {
                SoundManager.playMatch(); // SFX
                resolveMatch(ballIndex, target.typeIndex);
            } else {
                SoundManager.playHit(); // SFX
                insertBall(projectile, ballIndex);
            }
        }

        function resolveMatch(index, typeIdx) {
            let start = index;
            while (start > 0 && balls[start - 1].typeIndex === typeIdx) {
                start--;
            }
            let end = index;
            while (end < balls.length - 1 && balls[end + 1].typeIndex === typeIdx) {
                end++;
            }

            let count = end - start + 1;

            if (fireState.unlocked && fireState.charge < config.fireChargeReq) {
                fireState.charge += count;
                if (fireState.charge > config.fireChargeReq) fireState.charge = config.fireChargeReq;
            }

            let powerupsToActivate = [];
            for (let k = start; k <= end; k++) {
                if (balls[k].powerup) powerupsToActivate.push(balls[k].powerup);
            }
            for (let k = start; k <= end; k++) {
                SoundManager.playExplosion();
                createExplosion(getPositionAtDistance(balls[k].distance), typeColorMap[balls[k].typeIndex]);
            }

            balls.splice(start, count);

            for (let p of powerupsToActivate) {
                activatePowerup(p);
            }

            score += 100 * count;
        }

        function activatePowerup(p) {
            if (p.type === 'flame') {
                for (let b of balls) {
                    createExplosion(getPositionAtDistance(b.distance), typeColorMap[b.typeIndex]);
                }
                balls = [];
                score += 1000;
            } else if (p.type === 'freeze') {
                freezeTimer = p.duration;
            } else if (p.type === 'reverse') {
                reverseTimer = p.duration;
            }
        }

        function insertBall(projectile, hitIndex) {
            let target = balls[hitIndex];

            // REMOVED RAGE ON MISS (User Request)
            // Just a normal insert now

            let newBall = new Ball(target.distance, projectile.typeIndex);

            for (let k = 0; k <= hitIndex; k++) {
                balls[k].distance += config.ballSpacing;
            }

            newBall.distance = balls[hitIndex].distance - config.ballSpacing;
            balls.splice(hitIndex + 1, 0, newBall);

            score -= 10;
        }

        function createExplosion(pos, color) {
            if (!pos) return;
            // More particles for splatter
            for (let i = 0; i < 40; i++) {
                particles.push(new Particle(pos.x, pos.y, color));
            }
        }

        function drawPath() {
            if (pathPoints.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
            for (let i = 1; i < pathPoints.length; i++) {
                ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
            }
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'rgba(255,255,255,0.2)';

            // Visual feedback for RAGE (Pulse Red)
            if (rageTimer > 0) {
                ctx.strokeStyle = `rgba(255,0,0, ${0.5 + Math.sin(Date.now() / 50) * 0.5})`;
                ctx.lineWidth = config.ballRadius * 2 + 15;
            } else {
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = config.ballRadius * 2 + 10;
            }

            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = config.ballRadius * 2;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        function drawQueue() {
            const centerX = canvas.width / 2;
            const bottomY = canvas.height - 50;

            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = 'bold 16px "Segoe UI"';
            ctx.textAlign = 'center';
            ctx.fillText("NEXT", centerX, bottomY - 50);

            let totalWidth = (shooter.queue.length - 1) * 60;
            let startX = centerX - totalWidth / 2;

            for (let i = 0; i < shooter.queue.length; i++) {
                let typeIdx = shooter.queue[i];
                let angleVal = ANGLE_DEFS[typeIdx].c;

                let x = startX + i * 60;
                let y = bottomY;

                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);

                let grad = ctx.createRadialGradient(x - 8, y - 8, 4, x, y, 25);
                grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                grad.addColorStop(0.5, 'rgba(200,200,255,0.3)');
                grad.addColorStop(1, 'rgba(255,255,255,0.1)');
                ctx.fillStyle = grad;
                ctx.fill();

                ctx.strokeStyle = 'rgba(200, 200, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px "Segoe UI", Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 4;
                ctx.fillText(angleVal + '¬∞', x, y);
                ctx.shadowBlur = 0;
            }
        }


        function drawShooter() {
            ctx.save();
            ctx.translate(shooter.x, shooter.y);
            ctx.rotate(shooter.angle);

            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(35, 0);
            ctx.lineTo(300, 0);
            ctx.stroke();
            ctx.restore();

            ctx.shadowBlur = 15;
            ctx.shadowColor = '#4cc9f0';

            if (laserState.active) {
                ctx.fillStyle = '#f0f';
                ctx.shadowColor = '#f0f';
            } else {
                ctx.fillStyle = '#4361ee';
                ctx.shadowColor = '#4cc9f0';
            }

            ctx.beginPath();
            ctx.moveTo(25, 0);
            ctx.lineTo(-20, 20);
            ctx.lineTo(-20, -20);
            ctx.fill();

            ctx.fillStyle = '#3a0ca3';
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.restore();

            if (shooter.nextBall && !laserState.active) {
                let bx = shooter.x;
                let by = shooter.y;

                ctx.beginPath();
                ctx.arc(bx, by, config.ballRadius, 0, Math.PI * 2);

                let grad = ctx.createRadialGradient(bx - 10, by - 10, 5, bx, by, config.ballRadius);
                grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                grad.addColorStop(0.5, 'rgba(200,200,255,0.4)');
                grad.addColorStop(1, 'rgba(255,255,255,0.1)');
                ctx.fillStyle = grad;
                ctx.fill();

                ctx.strokeStyle = 'rgba(200, 200, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 22px "Segoe UI", Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 4;
                ctx.shadowColor = 'black';
                ctx.fillText(shooter.nextBall.angle + '¬∞', bx, by);
                ctx.shadowBlur = 0;
            }
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('final-score').innerText = `Final Score: ${score}`;
            document.getElementById('game-over-screen').style.display = 'flex';
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPath();

            if (pathPoints.length > 0) {
                let end = pathPoints[pathPoints.length - 1];
                ctx.beginPath();
                ctx.arc(end.x, end.y, config.ballRadius * 1.8, 0, Math.PI * 2);
                ctx.fillStyle = '#111';
                ctx.fill();
                ctx.strokeStyle = '#f72585';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.arc(end.x, end.y, config.ballRadius * 1.8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            update();

            for (let i = balls.length - 1; i >= 0; i--) {
                balls[i].draw();
            }

            for (let p of projectiles) p.draw();
            for (let pt of particles) pt.draw();

            drawShooter();
            drawQueue();

            requestAnimationFrame(loop);
        }

    </script>
</body>

</html>
